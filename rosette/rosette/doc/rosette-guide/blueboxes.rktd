9309
((3) 0 () 42 ((q lib "rosette/base/base.rkt") (q 3352 . 7) (q lib "rosette/lib/synthax.rkt") (q 5378 . 7) (q lib "rosette/solver/solution.rkt") (q lib "rosette/base/core/type.rkt") (q lib "rosette/query/form.rkt") (q lib "rosette/solver/solver.rkt") (q lib "rosette/lib/value-browser.rkt") (q lib "rosette/solver/smt/yices.rkt") (q 2050 . 28) (q lib "rosette/base/core/term.rkt") (q lib "rosette/base/core/function.rkt") (q lib "rosette/base/core/forall.rkt") (q 1420 . 7) (q 3548 . 16) (q 6364 . 16) (q lib "rosette/solver/smt/boolector.rkt") (q 9151 . 9) (q 9527 . 9) (q lib "rosette/solver/smt/cvc4.rkt") (q 8800 . 9) (q 3022 . 10) (q lib "rosette/query/finitize.rkt") (q lib "rosette/base/core/reflect.rkt") (q lib "rosette/lib/destruct.rkt") (q lib "rosette/solver/smt/z3.rkt") (q 8499 . 9) (q 5200 . 7) (q 4634 . 5) (q 1283 . 7) (q 2827 . 7) (q 7712 . 7) (q 4814 . 5) (q 4332 . 5) (q 4162 . 7) (q 1181 . 5) (q 6716 . 7) (q lib "rosette/base/form/define.rkt") (q lib "rosette/query/query.rkt") (q 4938 . 9) (q lib "rosette/base/core/union.rkt")) () (h ! (equal) ((c def c (c (? . 23) q output-smt)) q (8340 . 4)) ((c form c (c (? . 25) q destruct*)) q (11378 . 2)) ((c def c (c (? . 2) q generate-forms)) q (11111 . 3)) ((c def c (c (? . 8) q render-value/snip)) q (11501 . 5)) ((c def c (c (? . 0) q bvmul)) c (? . 1)) ((c def c (c (? . 0) q drop-bv)) c (? . 16)) ((c def c (c (? . 0) q bvsmin)) c (? . 40)) ((c def c (c (? . 12) q ~>)) q (5845 . 4)) ((c def c (c (? . 0) q bitvector->integer)) c (? . 34)) ((c def c (c (? . 0) q result-value)) q (13336 . 3)) ((c def c (c (? . 0) q bvand)) c (? . 31)) ((c def c (c (? . 0) q vector-set!-bv)) q (7074 . 5)) ((c def c (c (? . 0) q rotate-left)) c (? . 3)) ((c def c (c (? . 0) q vc-true?)) q (13101 . 3)) ((c def c (c (? . 0) q bvadd)) c (? . 1)) ((c form c (c (? . 2) q define-simple-grammar)) q (10943 . 2)) ((c def c (c (? . 0) q bvult)) c (? . 10)) ((c form c (c (? . 2) q define-grammar)) q (10869 . 3)) ((c def c (c (? . 4) q model)) q (10331 . 3)) ((c def c (c (? . 0) q extract)) q (4034 . 5)) ((c def c (c (? . 0) q bv)) q (1777 . 5)) ((c def c (c (? . 41) q union?)) q (12504 . 3)) ((c def c (c (? . 0) q bvsmod)) c (? . 15)) ((c def c (c (? . 0) q rotate-right)) c (? . 3)) ((c def c (c (? . 4) q solution?)) q (9873 . 3)) ((c def c (c (? . 0) q msb)) c (? . 29)) ((c def c (c (? . 9) q yices)) c (? . 19)) ((c def c (c (? . 2) q current-grammar-depth)) q (10999 . 5)) ((c form c (c (? . 6) q optimize)) q (578 . 14)) ((c def c (c (? . 0) q <=>)) c (? . 30)) ((c def c (c (? . 5) q solvable?)) q (12449 . 3)) ((c form c (c (? . 11) q term)) q (12072 . 2)) ((c def c (c (? . 0) q zero-extend)) c (? . 35)) ((c def c (c (? . 0) q bitvector)) q (1602 . 3)) ((c def c (c (? . 0) q bv?)) q (2001 . 3)) ((c def c (c (? . 4) q unsat?)) q (9978 . 3)) ((c def c (c (? . 7) q solver-debug)) q (8029 . 3)) ((c def c (c (? . 5) q type-of)) q (12342 . 3)) ((c def c (c (? . 0) q concat)) q (3983 . 3)) ((c def c (c (? . 0) q bvneg)) q (3286 . 3)) ((c def c (c (? . 0) q bvashr)) c (? . 22)) ((c def c (c (? . 4) q unknown)) q (10297 . 2)) ((c def c (c (? . 0) q result?)) q (13283 . 3)) ((c form c (c (? . 6) q synthesize)) q (440 . 3)) ((c def c (c (? . 5) q type?)) q (12398 . 3)) ((c def c (c (? . 7) q solver-options)) q (8252 . 3)) ((c def c (c (? . 0) q vc-true)) q (13079 . 2)) ((c def c (c (? . 8) q render-value/window)) q (11704 . 5)) ((c def c (c (? . 6) q solve+)) q (543 . 2)) ((c def c (c (? . 0) q distinct?)) q (1071 . 3)) ((c def c (c (? . 17) q boolector?)) c (? . 18)) ((c def c (c (? . 9) q yices-available?)) q (9830 . 2)) ((c def c (c (? . 0) q bvuge)) c (? . 10)) ((c def c (c (? . 0) q result-state)) q (13393 . 3)) ((c form c (c (? . 13) q for*/all)) q (12796 . 5)) ((c form c (c (? . 6) q verify)) q (418 . 2)) ((c form c (c (? . 6) q solve)) q (522 . 2)) ((c def c (c (? . 0) q forall)) c (? . 14)) ((c def c (c (? . 26) q z3)) c (? . 27)) ((c form c (c (? . 2) q ??)) q (10705 . 7)) ((c def c (c (? . 7) q solver-assert)) q (7362 . 4)) ((c form c (c (? . 11) q constant)) q (12138 . 2)) ((c def c (c (? . 12) q fv?)) q (6040 . 3)) ((c def c (c (? . 39) q evaluate)) q (10517 . 4)) ((c form c (c (? . 13) q for/all)) q (12671 . 5)) ((c def c (c (? . 0) q exists)) c (? . 14)) ((c def c (c (? . 4) q sat)) q (10084 . 4)) ((c def c (c (? . 7) q solver-pop)) q (7548 . 4)) ((c def c (c (? . 4) q unsat)) q (10195 . 4)) ((c def c (c (? . 24) q symbolic?)) q (12287 . 3)) ((c def c (c (? . 0) q bvurem)) c (? . 15)) ((c def c (c (? . 4) q complete-solution)) q (10590 . 4)) ((c def c (c (? . 0) q bitvector?)) q (1721 . 3)) ((c def c (c (? . 11) q constant?)) q (12017 . 3)) ((c def c (c (? . 0) q take-right-bv)) c (? . 16)) ((c def c (c (? . 17) q boolector)) c (? . 18)) ((c def c (c (? . 9) q yices?)) c (? . 19)) ((c def c (c (? . 0) q gc-terms!)) q (13683 . 2)) ((c def c (c (? . 0) q terms)) q (13556 . 2)) ((c def c (c (? . 0) q bvzero?)) q (4752 . 3)) ((c def c (c (? . 7) q solver-clear)) q (7645 . 3)) ((c def c (c (? . 0) q bool->bitvector)) q (5713 . 4)) ((c def c (c (? . 20) q cvc4)) c (? . 21)) ((c def c (c (? . 0) q vc)) q (13155 . 2)) ((c def c (c (? . 20) q cvc4?)) c (? . 21)) ((c def c (c (? . 0) q clear-terms!)) q (13595 . 3)) ((c def c (c (? . 0) q bvsge)) c (? . 10)) ((c def c (c (? . 0) q integer->bitvector)) q (4446 . 4)) ((c def c (c (? . 0) q bvsrem)) c (? . 15)) ((c def c (c (? . 0) q bit)) q (4548 . 4)) ((c def c (c (? . 0) q !)) q (1131 . 3)) ((c def c (c (? . 0) q failed?)) q (13503 . 3)) ((c def c (c (? . 0) q bvlshr)) c (? . 22)) ((c def c (c (? . 4) q core)) q (10420 . 3)) ((c def c (c (? . 0) q list-tail-bv)) c (? . 16)) ((c form c (c (? . 0) q with-terms)) q (13716 . 5)) ((c def c (c (? . 7) q solver-push)) q (7482 . 3)) ((c def c (c (? . 0) q bvslt)) c (? . 10)) ((c def c (c (? . 0) q bitvector->bits)) q (5557 . 3)) ((c def c (c (? . 23) q current-bitwidth)) q (926 . 5)) ((c def c (c (? . 7) q solver?)) q (7309 . 3)) ((c def c (c (? . 0) q bvsgt)) c (? . 10)) ((c def c (c (? . 24) q concrete?)) q (12232 . 3)) ((c def c (c (? . 0) q bvule)) c (? . 10)) ((c def c (c (? . 0) q drop-right-bv)) c (? . 16)) ((c def c (c (? . 0) q bvrol)) c (? . 28)) ((c def c (c (? . 0) q bitvector->bool)) q (5643 . 3)) ((c def c (c (? . 7) q solver-maximize)) c (? . 32)) ((c form c (c (? . 2) q choose)) q (10841 . 2)) ((c form c (c (? . 25) q destruct-lambda)) q (11445 . 2)) ((c def c (c (? . 2) q print-forms)) q (11198 . 3)) ((c def c (c (? . 4) q unknown?)) q (10030 . 3)) ((c def c (c (? . 0) q bvugt)) c (? . 10)) ((c def c (c (? . 0) q bvsub1)) c (? . 33)) ((c def c (c (? . 11) q expression?)) q (11960 . 3)) ((c def c (c (? . 11) q term?)) q (11909 . 3)) ((c def c (c (? . 0) q bvudiv)) c (? . 15)) ((c def c (c (? . 0) q normal?)) q (13450 . 3)) ((c def c (c (? . 4) q sat?)) q (9928 . 3)) ((c def c (c (? . 26) q z3?)) c (? . 27)) ((c def c (c (? . 0) q vc-assumes)) q (12971 . 3)) ((c def c (c (? . 0) q bvshl)) c (? . 22)) ((c def c (c (? . 0) q bvror)) c (? . 28)) ((c def c (c (? . 0) q bveq)) c (? . 10)) ((c def c (c (? . 0) q vector-ref-bv)) q (6991 . 4)) ((c def c (c (? . 0) q bvsdiv)) c (? . 15)) ((c def c (c (? . 0) q list-ref-bv)) q (6183 . 4)) ((c def c (c (? . 0) q bvnot)) q (2761 . 3)) ((c def c (c (? . 0) q take-bv)) c (? . 16)) ((c def c (c (? . 0) q lsb)) c (? . 29)) ((c def c (c (? . 0) q vc-asserts)) q (13025 . 3)) ((c def c (c (? . 0) q =>)) c (? . 30)) ((c form c (c (? . 0) q assume)) q (353 . 5)) ((c def c (c (? . 20) q cvc4-available?)) q (9109 . 2)) ((c def c (c (? . 0) q vc?)) q (12922 . 3)) ((c def c (c (? . 7) q solver-features)) q (8170 . 3)) ((c def c (c (? . 0) q bvor)) c (? . 31)) ((c form c (c (? . 38) q define-symbolic)) q (0 . 6)) ((c def c (c (? . 7) q solver-minimize)) c (? . 32)) ((c form c (c (? . 25) q destruct)) q (11326 . 2)) ((c def c (c (? . 0) q bvadd1)) c (? . 33)) ((c def c (c (? . 0) q bvxor)) c (? . 31)) ((c def c (c (? . 0) q vector-length-bv)) q (6888 . 4)) ((c def c (c (? . 7) q solver-shutdown)) q (8100 . 3)) ((c form c (c (? . 0) q with-vc)) q (13212 . 5)) ((c def c (c (? . 0) q length-bv)) q (6089 . 4)) ((c def c (c (? . 0) q split-at-bv)) c (? . 37)) ((c def c (c (? . 0) q bitvector->natural)) c (? . 34)) ((c def c (c (? . 0) q sign-extend)) c (? . 35)) ((c def c (c (? . 0) q ||)) c (? . 36)) ((q def ((lib "rosette/lib/angelic.rkt") choose*)) q (11270 . 3)) ((c def c (c (? . 0) q bvsub)) c (? . 1)) ((c def c (c (? . 0) q &&)) c (? . 36)) ((c def c (c (? . 17) q boolector-available?)) q (9480 . 2)) ((c def c (c (? . 0) q split-at-right-bv)) c (? . 37)) ((c def c (c (? . 7) q gen:solver)) q (7280 . 2)) ((c def c (c (? . 12) q function?)) q (5985 . 3)) ((c def c (c (? . 0) q list-set-bv)) q (6262 . 5)) ((c form c (c (? . 38) q define-symbolic*)) q (143 . 6)) ((c def c (c (? . 7) q solver-check)) q (7958 . 3)) ((c def c (c (? . 39) q current-solver)) q (7181 . 4)) ((c def c (c (? . 0) q clear-vc!)) q (13179 . 2)) ((c def c (c (? . 0) q bvumin)) c (? . 40)) ((c def c (c (? . 24) q symbolics)) q (12166 . 3)) ((c def c (c (? . 0) q bvsmax)) c (? . 40)) ((c def c (c (? . 41) q union-contents)) q (12556 . 4)) ((c form c (c (? . 11) q expression)) q (12101 . 2)) ((c def c (c (? . 0) q bvumax)) c (? . 40)) ((c form c (c (? . 0) q assert)) q (288 . 5)) ((c def c (c (? . 0) q bvsle)) c (? . 10))))
syntax
(define-symbolic id ...+ type)
(define-symbolic id type #:length k)
 
  type : (and/c solvable? type?)
  k : natural?
syntax
(define-symbolic* id ...+ type)
(define-symbolic* id type #:length k)
 
  type : (and/c solvable? type?)
  k : natural?
syntax
(assert expr)
(assert expr msg)
 
  msg : string?
syntax
(assume expr)
(assume expr msg)
 
  msg : string?
syntax
(verify expr)
syntax
(synthesize input expr)
(synthesize #:forall input #:guarantee expr)
syntax
(solve expr)
procedure
(solve+) -> procedure?
syntax
(optimize
   maybe-minimize
   maybe-maximize
   #:guarantee expr)
 
maybe-minimize = 
               | #:minimize min-expr
                  
maybe-maximize = 
               | #:maximize max-expr
 
  min-expr : (listof (or/c integer? real? bv?))
  max-expr : (listof (or/c integer? real? bv?))
parameter
(current-bitwidth) -> (or/c #f positive-integer?)
(current-bitwidth k) -> void?
  k : (or/c #f positive-integer?)
 = #f
procedure
(distinct? v ...) -> boolean?
  v : any/c
procedure
(! v) -> boolean?
  v : boolean?
procedure
(&& v ...) -> boolean?
  v : boolean?
(|| v ...) -> boolean?
  v : boolean?
procedure
(=> x y) -> boolean?
  x : boolean?
  y : boolean?
(<=> x y) -> boolean?
  x : boolean?
  y : boolean?
procedure
(forall vs body) -> boolean?
  vs : (listof constant?)
  body : boolean?
(exists vs body) -> boolean?
  vs : (listof constant?)
  body : boolean?
procedure
(bitvector size) -> bitvector?
  size : (and/c integer? positive? (not/c term?) (not/c union?))
procedure
(bitvector? v) -> boolean?
  v : any/c
procedure
(bv val size) -> bv?
  val : (and/c integer? (not/c term?) (not/c union?))
  size : (and/c (or/c bitvector? (and/c integer? positive?))
                (not/c term?) (not/c union?))
procedure
(bv? v) -> boolean?
  v : any/c
procedure
(bveq x y) -> boolean?
  x : (bitvector n)
  y : (bitvector n)
(bvslt x y) -> boolean?
  x : (bitvector n)
  y : (bitvector n)
(bvult x y) -> boolean?
  x : (bitvector n)
  y : (bitvector n)
(bvsle x y) -> boolean?
  x : (bitvector n)
  y : (bitvector n)
(bvule x y) -> boolean?
  x : (bitvector n)
  y : (bitvector n)
(bvsgt x y) -> boolean?
  x : (bitvector n)
  y : (bitvector n)
(bvugt x y) -> boolean?
  x : (bitvector n)
  y : (bitvector n)
(bvsge x y) -> boolean?
  x : (bitvector n)
  y : (bitvector n)
(bvuge x y) -> boolean?
  x : (bitvector n)
  y : (bitvector n)
procedure
(bvnot x) -> (bitvector n)
  x : (bitvector n)
procedure
(bvand x ...+) -> (bitvector n)
  x : (bitvector n)
(bvor x ...+) -> (bitvector n)
  x : (bitvector n)
(bvxor x ...+) -> (bitvector n)
  x : (bitvector n)
procedure
(bvshl x y) -> (bitvector n)
  x : (bitvector n)
  y : (bitvector n)
(bvlshr x y) -> (bitvector n)
  x : (bitvector n)
  y : (bitvector n)
(bvashr x y) -> (bitvector n)
  x : (bitvector n)
  y : (bitvector n)
procedure
(bvneg x) -> (bitvector n)
  x : (bitvector n)
procedure
(bvadd x ...+) -> (bitvector n)
  x : (bitvector n)
(bvsub x ...+) -> (bitvector n)
  x : (bitvector n)
(bvmul x ...+) -> (bitvector n)
  x : (bitvector n)
procedure
(bvsdiv x y) -> (bitvector n)
  x : (bitvector n)
  y : (bitvector n)
(bvudiv x y) -> (bitvector n)
  x : (bitvector n)
  y : (bitvector n)
(bvsrem x y) -> (bitvector n)
  x : (bitvector n)
  y : (bitvector n)
(bvurem x y) -> (bitvector n)
  x : (bitvector n)
  y : (bitvector n)
(bvsmod x y) -> (bitvector n)
  x : (bitvector n)
  y : (bitvector n)
procedure
(concat x ...+) -> bv?
  x : bv?
procedure
(extract i j x) -> (bitvector (+ 1 (- i j)))
  i : integer?
  j : integer?
  x : (bitvector n)
procedure
(sign-extend x t) -> bv?
  x : bv?
  t : (or/c bitvector? union?)
(zero-extend x t) -> bv?
  x : bv?
  t : (or/c bitvector? union?)
procedure
(bitvector->integer x) -> integer?
  x : bv?
(bitvector->natural x) -> integer?
  x : bv?
procedure
(integer->bitvector i t) -> bv?
  i : integer?
  t : (or/c bitvector? union?)
procedure
(bit i x) -> (bitvector 1)
  i : integer?
  x : (bitvector n)
procedure
(lsb x) -> (bitvector 1)
  x : (bitvector n)
(msb x) -> (bitvector 1)
  x : (bitvector n)
procedure
(bvzero? x) -> boolean?
  x : (bitvector n)
procedure
(bvadd1 x) -> (bitvector n)
  x : (bitvector n)
(bvsub1 x) -> (bitvector n)
  x : (bitvector n)
procedure
(bvsmin x ...+) -> (bitvector n)
  x : (bitvector n)
(bvumin x ...+) -> (bitvector n)
  x : (bitvector n)
(bvsmax x ...+) -> (bitvector n)
  x : (bitvector n)
(bvumax x ...+) -> (bitvector n)
  x : (bitvector n)
procedure
(bvrol x y) -> (bitvector n)
  x : (bitvector n)
  y : (bitvector n)
(bvror x y) -> (bitvector n)
  x : (bitvector n)
  y : (bitvector n)
procedure
(rotate-left i x) -> (bitvector n)
  i : integer?
  x : (bitvector n)
(rotate-right i x) -> (bitvector n)
  i : integer?
  x : (bitvector n)
procedure
(bitvector->bits x) -> (listof (bitvector n))
  x : (bitvector n)
procedure
(bitvector->bool x) -> boolean?
  x : (bitvector n)
procedure
(bool->bitvector b [t]) -> bv?
  b : any/c
  t : (or/c positive-integer? (bitvector n)) = (bitvector 1)
procedure
(~> d ...+ r) -> function?
  d : (and/c solvable? (not/c function?))
  r : (and/c solvable? (not/c function?))
procedure
(function? v) -> boolean?
  v : any/c
procedure
(fv? v) -> boolean?
  v : any/c
procedure
(length-bv lst t) -> bv?
  lst : list?
  t : (or/c bitvector? union?)
procedure
(list-ref-bv lst pos) -> any/c
  lst : list?
  pos : bv?
procedure
(list-set-bv lst pos val) -> list?
  lst : list?
  pos : bv?
  val : any/c
procedure
(take-bv lst pos) -> list?
  lst : any/c
  pos : bv?
(take-right-bv lst pos) -> any/c
  lst : any/c
  pos : bv?
(drop-bv lst pos) -> any/c
  lst : any/c
  pos : bv?
(drop-right-bv lst pos) -> list?
  lst : any/c
  pos : bv?
(list-tail-bv lst pos) -> any/c
  lst : any/c
  pos : bv?
procedure
(split-at-bv lst pos) -> (list? any/c)
  lst : any/c
  pos : bv?
(split-at-right-bv lst pos) -> (list? any/c)
  lst : any/c
  pos : bv?
procedure
(vector-length-bv vec t) -> bv?
  vec : vector?
  t : (or/c bitvector? union?)
procedure
(vector-ref-bv vec pos) -> any/c
  vec : vector?
  pos : bv?
procedure
(vector-set!-bv vec pos val) -> void?
  vec : vector?
  pos : bv?
  val : any/c
parameter
(current-solver) -> solver?
(current-solver solver) -> void?
  solver : solver?
value
gen:solver : solver?
procedure
(solver? v) -> boolean?
  v : any/c
procedure
(solver-assert solver constraints) -> void?
  solver : solver?
  constraints : (listof boolean?)
procedure
(solver-push solver) -> void?
  solver : solver?
procedure
(solver-pop solver levels) -> void?
  solver : solver?
  levels : integer?
procedure
(solver-clear solver) -> void?
  solver : solver?
procedure
(solver-minimize solver objs) -> void?
  solver : solver?
  objs : (listof (or/c integer? real? bv?))
(solver-maximize solver objs) -> void?
  solver : solver?
  objs : (listof (or/c integer? real? bv?))
procedure
(solver-check solver) -> solution?
  solver : solver?
procedure
(solver-debug solver) -> solution?
  solver : solver?
procedure
(solver-shutdown solver) -> void?
  solver : solver?
procedure
(solver-features solver) -> (listof symbol?)
  solver : solver?
procedure
(solver-options solver) -> (hash/c symbol? any/c)
  solver : solver?
parameter
(output-smt) -> (or/c boolean? path-string? output-port?)
(output-smt on?) -> void?
  on? : (or/c boolean? path-string? output-port?)
procedure
(z3 [#:path path             
     #:logic logic           
     #:options options]) -> solver?
  path : (or/c path-string? #f) = #f
  logic : (or/c symbol? #f) = #f
  options : (hash/c symbol? any/c) = (hash)
(z3? v) -> boolean?
  v : any/c
procedure
(cvc4 [#:path path             
       #:logic logic           
       #:options options]) -> solver?
  path : (or/c path-string? #f) = #f
  logic : (or/c symbol? #f) = #f
  options : (hash/c symbol? any/c) = (hash)
(cvc4? v) -> boolean?
  v : any/c
procedure
(cvc4-available?) -> boolean?
procedure
(boolector [#:path path             
            #:logic logic           
            #:options options]) -> solver?
  path : (or/c path-string? #f) = #f
  logic : (or/c symbol? #f) = #f
  options : (hash/c symbol? any/c) = (hash)
(boolector? v) -> boolean?
  v : any/c
procedure
(boolector-available?) -> boolean?
procedure
(yices [#:path path             
        #:logic logic           
        #:options options]) -> solver?
  path : (or/c path-string? #f) = #f
  logic : symbol? = 'ALL
  options : (hash/c symbol? any/c) = (hash)
(yices? v) -> boolean?
  v : any/c
procedure
(yices-available?) -> boolean?
procedure
(solution? v) -> boolean?
  v : any/c
procedure
(sat? v) -> boolean?
  v : any/c
procedure
(unsat? v) -> boolean?
  v : any/c
procedure
(unknown? v) -> boolean?
  v : any/c
procedure
(sat) -> sat?
(sat binding) -> sat?
  binding : (hash/c constant? any/c #:immutable #t)
procedure
(unsat) -> unsat?
(unsat constraints) -> unsat?
  constraints : (listof boolean?)
procedure
(unknown) -> unknown?
procedure
(model sol) -> (hash/c constant? any/c #:immutable #t)
  sol : sat?
procedure
(core sol) -> (or/c (listof (and/c constant? boolean?)) #f)
  sol : unsat?
procedure
(evaluate v sol) -> any/c
  v : any/c
  sol : sat?
procedure
(complete-solution sol consts) -> solution?
  sol : solution?
  consts : (listof constant?)
syntax
(?? maybe-type)
 
maybe-type = 
           | type-expr
 
  type-expr : (and/c solvable? type? (not/c function?))
syntax
(choose expr ...+)
syntax
(define-grammar (id arg-id ...)
  [rule-id rule-expr] ...+)
syntax
(define-simple-grammar (id arg-id ...) body)
parameter
(current-grammar-depth) -> natural?
(current-grammar-depth n) -> void?
  n : natural?
 = 0
procedure
(generate-forms solution) -> (listof syntax?)
  solution : solution?
procedure
(print-forms solution) -> void?
  solution : solution?
procedure
(choose* v ...+) -> any/c
  v : any/c
syntax
(destruct val-expr [pat body ...+] ...)
syntax
(destruct* (val-expr ...) [(pat ...) body ...+] ...)
syntax
(destruct-lambda [(pat ...) body ...+] ...)
procedure
(render-value/snip val [#:handler handler]) -> (is-a?/c snip%)
  val : any/c
  handler : (-> any/c (-> any/c (is-a?/c snip%)) layout)
          = (λ (value rec) #f)
procedure
(render-value/window val [#:handler handler]) -> (is-a?/c snip%)
  val : any/c
  handler : (-> any/c (-> any/c (is-a?/c snip%)) layout)
          = (λ (value rec) #f)
procedure
(term? v) -> boolean?
  v : any/c
procedure
(expression? v) -> boolean?
  v : any/c
procedure
(constant? v) -> boolean?
  v : any/c
syntax
(term content type)
syntax
(expression op child ...+)
syntax
(constant id type)
procedure
(symbolics v) -> (listof constant?)
  v : any/c
procedure
(concrete? v) -> boolean?
  v : any/c
procedure
(symbolic? v) -> boolean?
  v : any/c
procedure
(type-of v ...+) -> type?
  v : any/c
procedure
(type? v) -> boolean?
  v : any/c
procedure
(solvable? v) -> boolean?
  v : any/c
procedure
(union? v) -> boolean?
  v : any/c
procedure
(union-contents u)
 -> (listof (cons/c (and/c boolean? term?) (not/c union?)))
  u : union?
syntax
(for/all ([id val-expr maybe-exhaustive]) body ...+)
 
maybe-exhaustive = 
                 | #:exhaustive
syntax
(for*/all ([id val-expr maybe-exhaustive]) body ...+)
 
maybe-exhaustive = 
                 | #:exhaustive
procedure
(vc? v) -> boolean?
  v : any/c
procedure
(vc-assumes v) -> boolean?
  v : vc?
procedure
(vc-asserts v) -> boolean?
  v : vc?
value
vc-true : vc?
procedure
(vc-true? v) -> boolean?
  v : any/c
procedure
(vc) -> vc?
procedure
(clear-vc!) -> void?
syntax
(with-vc expr)
(with-vc vc-expr expr)
 
  vc-expr : vc?
procedure
(result? v) -> boolean?
  v : any/c
procedure
(result-value v) -> any/c
  v : result?
procedure
(result-state v) -> any/c
  v : result?
procedure
(normal? v) -> boolean?
  v : any/c
procedure
(failed? v) -> boolean?
  v : any/c
procedure
(terms) -> (listof term?)
procedure
(clear-terms! [ts]) -> void?
  ts : (or/c #f (listof term?)) = #f
procedure
(gc-terms!) -> void?
syntax
(with-terms expr)
(with-terms terms-expr expr)
 
  terms-expr : (listof term?)
